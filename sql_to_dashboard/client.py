#!/usr/bin/env python3
"""Simplified CLI Client for SQL to Dashboard - Version 2.0
One command to generate everything: query + dashboard.
"""

import click
import json
from pathlib import Path
from typing import List

from schemas import GenerateRequest
from server import SqlToDashboardServer


@click.command()
@click.option('--schema', '-s', 'schema_file', required=True, 
              type=click.Path(exists=True),
              help='DDL schema file (SQL CREATE TABLE statements)')
@click.option('--intents', '-i', multiple=True, required=True,
              help='What insights you want (e.g., "sales trends", "customer analytics")')
@click.option('--output', '-o', 'output_dir', default='./output',
              type=click.Path(),
              help='Output directory for generated files')
@click.option('--database', '-d', 
              type=click.Choice(['sqlite', 'postgres', 'mysql']),
              default='sqlite',
              help='Target database type')
def generate(schema_file: str, intents: List[str], output_dir: str, database: str):
    """
    Generate SQL query and dashboard from DDL schema.
    
    Simple one-command workflow:
    
    \b
    Examples:
        # Basic usage
        python client.py -s schema.sql -i "sales analysis" -i "customer trends"
        
        # PostgreSQL with custom output
        python client.py -s schema.sql -i "revenue" -d postgres -o ./dashboards
    
    \b
    This generates:
        - query.sql: Master query joining all tables
        - dashboard.html: Interactive D3.js dashboard
        - execute.sh: Script to run the query
        - README.md: Instructions
    """
    print("üöÄ SQL to Dashboard Generator v2.0")
    print("=" * 50)
    
    try:
        # Read DDL file
        with open(schema_file, 'r') as f:
            ddl = f.read()
        
        print(f"üìÑ Schema: {schema_file}")
        print(f"üéØ Intents: {', '.join(intents)}")
        print(f"üíæ Database: {database}")
        print(f"üìÅ Output: {output_dir}")
        print("-" * 50)
        
        # Create server and generate everything
        server = SqlToDashboardServer()
        request = GenerateRequest(
            ddl=ddl,
            intents=list(intents),
            database=database
        )
        
        print("‚öôÔ∏è Processing...")
        response = server.generate_all(request)
        
        # Create output directory
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        # Save all files
        files_created = []
        
        # 1. SQL Query
        query_file = output_path / "query.sql"
        with open(query_file, 'w') as f:
            f.write(f"-- Generated Master Query\n")
            f.write(f"-- Intents: {', '.join(intents)}\n")
            f.write(f"-- Database: {database}\n\n")
            f.write(response.query)
        files_created.append("query.sql")
        
        # 2. Dashboard HTML
        dashboard_file = output_path / "dashboard.html"
        with open(dashboard_file, 'w') as f:
            f.write(response.dashboard_html)
        files_created.append("dashboard.html")
        
        # 3. Execution Script
        exec_file = output_path / "execute.sh"
        with open(exec_file, 'w') as f:
            f.write(response.execution_script)
        exec_file.chmod(0o755)  # Make executable
        files_created.append("execute.sh")
        
        # 4. README
        readme_file = output_path / "README.md"
        with open(readme_file, 'w') as f:
            f.write(f"""# Generated Dashboard

## Quick Start

1. **Execute the query** to get your data:
   ```bash
   ./execute.sh
   # Or manually run query.sql against your database
   ```

2. **Save results** as `data.json` in this directory

3. **Open dashboard** in your browser:
   ```bash
   open dashboard.html
   ```

## Generated Files

- `query.sql` - Master SQL query that joins all tables
- `dashboard.html` - Interactive D3.js dashboard (auto-loads data.json)
- `execute.sh` - Helper script to execute the query
- `data.json` - (You create this by executing the query)

## Your Configuration

- **Schema**: {schema_file}
- **Database**: {database}
- **Intents**: {', '.join(intents)}

## How It Works

1. The query returns ALL data in a flat, denormalized format
2. D3.js in the dashboard handles all aggregations and visualizations
3. The dashboard auto-refreshes when data.json is updated

Generated by SQL to Dashboard v2.0
""")
        files_created.append("README.md")
        
        # Success summary
        print("\n" + "=" * 50)
        print("‚úÖ SUCCESS! All files generated")
        print("=" * 50)
        
        print("\nüì¶ Files created:")
        for file in files_created:
            print(f"   ‚úì {output_path / file}")
        
        print("\nüöÄ Next steps:")
        print(f"   1. cd {output_dir}")
        print(f"   2. ./execute.sh  (or run query.sql manually)")
        print(f"   3. open dashboard.html")
        
        print("\nüí° The dashboard will auto-load data.json")
        print("   and create visualizations dynamically!")
        
    except FileNotFoundError:
        print(f"\n‚ùå Error: Schema file not found: {schema_file}")
        raise click.Abort()
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        raise click.Abort()


if __name__ == "__main__":
    generate()